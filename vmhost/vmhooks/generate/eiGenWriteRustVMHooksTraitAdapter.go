package vmhooksgenerate

import (
	"fmt"
)

// WriteRustVMHooksLegacyTrait autogenerate data in the provided file
func WriteRustVMHooksLegacyAdapter(out *eiGenWriter, eiMetadata *EIMetadata) {
	autoGeneratedHeader(out)
	out.WriteString(`
use std::ffi::c_void;

use crate::{BreakpointValue, MemLength, MemPtr, VMHooks, VMHooksError, VMHooksLegacy};

/// Allow conversion from the new VMHooks to the old.
///
/// Will eventually be removed, once everything gets migrated.
pub trait VMHooksLegacyAdapter: VMHooks {
    fn set_breakpoint_value(&self, value: BreakpointValue);

    fn unwrap_or_set_breakpoint<R>(&mut self, result: Result<R, VMHooksError>) -> R
    where
        R: Default,
    {
        result.unwrap_or_else(|err| {
            self.set_breakpoint_value(err);
            R::default()
        })
    }
}

#[rustfmt::skip]
impl<T> VMHooksLegacy for T where T: VMHooksLegacyAdapter {
    fn set_vm_hooks_ptr(&mut self, _vm_hooks_ptr: *mut c_void) {
    }
`)

	for _, funcMetadata := range eiMetadata.AllFunctions {
		out.WriteString(fmt.Sprintf(
			"\n    fn %s%s {\n",
			snakeCase(funcMetadata.Name),
			writeRustFnDeclarationArguments(
				"&mut self",
				funcMetadata,
				rustVMHooksType,
				rustVMHooksLegacyReturnType,
			),
		))

		out.WriteString(fmt.Sprintf(
			"        let result = VMHooks::%s(self",
			snakeCase(funcMetadata.Name),
		))
		for _, arg := range funcMetadata.Arguments {
			out.WriteString(", ")
			out.WriteString(snakeCase((arg.Name)))
		}
		out.WriteString(");\n")
		out.WriteString("        Self::unwrap_or_set_breakpoint(self, result)\n")
		out.WriteString("    }\n")
	}

	out.WriteString("}\n")

}
